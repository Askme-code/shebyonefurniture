
/**
 * Core Philosophy: This ruleset enforces a two-tiered access model: public/customer versus admin.
 * Admins have broad read/write access across the database, while customers are restricted to their
 * own data and can read public data. Anonymous users can only read public data.
 *
 * Data Structure:
 * - /products/{productId}: A public, top-level collection of all products.
 * - /orders/{orderId}: A top-level collection of all orders. Orders contain a `userId` field to link them to their owner.
 * - /roles_admin/{userId}: A lookup collection to identify administrators. The existence of a
 *   document here grants a user admin privileges across the entire database.
 *
 * Key Security Decisions:
 * - Admin Role Management: Administrator privileges are granted if a document exists for the user
 *   in the `/roles_admin` collection. This collection is read-only for clients to prevent any
 *   user from elevating their own permissions. It must be managed by a trusted server process.
 * - Ownership: Customer data, such as orders, is secured by a `userId` field within the document itself.
 *   This ensures users can only ever access their own information, even in a shared, top-level collection.
 * - Public Data: The `/products` collection is world-readable to allow anyone, including
 *   unauthenticated users, to browse the product catalog.
 *
 * Denormalization for Authorization:
 * The `/roles_admin/{userId}` collection is a prime example of denormalizing for authorization.
 * Instead of storing a 'role' field on a user document and requiring slow `get()` calls in rules,
 * we use a simple and fast `exists()` check against this collection to determine admin status.
 * This pattern is highly performant and secure.
 *
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // ----------------------------------------------------------------------
    // Helper Functions
    // ----------------------------------------------------------------------

    /**
     * Checks if the user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if the authenticated user is the owner of the document,
     * based on the userId provided in the path.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * Checks if the user has an admin role by verifying the existence of
     * their UID in the roles_admin collection.
     */
    function isAdmin() {
      return isSignedIn() && exists(/databases/$(database)/documents/roles_admin/$(request.auth.uid));
    }

    /**
     * Verifies that the document being modified or deleted already exists.
     * Prevents operations on non-existent documents.
     */
    function isExistingDoc() {
      return resource != null;
    }

    /**
     * On order update, enforces that the `userId` field is immutable,
     * preventing an order from being reassigned to a different user.
     */
    function isOrderDataValidOnUpdate() {
      return request.resource.data.userId == resource.data.userId;
    }

    /**
     * On order creation, validates that all required fields are present and the
     * initial status is 'Pending', improving data integrity.
     */
    function isValidOrderCreate() {
      let data = request.resource.data;
      return data.keys().hasAll([
        'customerName', 'phone', 'address', 'items', 'total', 'status', 'createdAt', 'userId'
      ]) && data.status == 'Pending';
    }


    // ----------------------------------------------------------------------
    // Collection Rules
    // ----------------------------------------------------------------------

    /**
     * @description Controls access to the public product catalog.
     * @path /products/{productId}
     * @allow (get, list) for any user, including unauthenticated users, to browse products.
     * @deny (create, update, delete) for non-admin users.
     * @principle Public read access for catalog data, with admin-only write controls.
     */
    match /products/{productId} {
      allow get, list: if true;
      allow create: if isAdmin();
      allow update: if isAdmin();
      allow delete: if isAdmin();
    }

    /**
     * @description Controls access to the top-level orders collection.
     * @path /orders/{orderId}
     * @allow (read) for an admin OR if the user is the owner of the order document.
     * @allow (create) if the user is the owner of the new order and the data is valid.
     * @allow (update, delete) for an admin OR if the user is the owner.
     * @principle A query from a user must be constrained with `where('userId', '==', auth.uid)` on the client.
     */
    match /orders/{orderId} {
      allow read: if isAdmin() || (isExistingDoc() && isOwner(resource.data.userId));
      allow create: if isOwner(request.resource.data.userId) && isValidOrderCreate();
      allow update: if (isAdmin() || (isExistingDoc() && isOwner(resource.data.userId))) && isOrderDataValidOnUpdate();
      allow delete: if isAdmin() || (isExistingDoc() && isOwner(resource.data.userId));
    }

    /**
     * @description Controls access to the admin role lookup collection.
     * @path /roles_admin/{userId}
     * @allow (get) A signed-in user can check their own role status.
     * @allow (list) An admin to see the list of other admins.
     * @deny All write operations (create, update, delete) from any client to prevent privilege escalation.
     * @principle Secures the authorization mechanism itself. This collection should only be managed by a trusted backend server.
     */
    match /roles_admin/{userId} {
      allow get: if isOwner(userId);
      allow list: if isAdmin();
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }
  }
}
