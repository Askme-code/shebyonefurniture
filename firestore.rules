/**
 * # Firestore Security Rules
 *
 * ## Core Philosophy
 * This ruleset establishes a clear security boundary between publicly accessible data (the product catalog) and private user-specific data (user profiles and orders). It implements a Database-Based Access Control (DBAC) model where administrative privileges are granted based on the existence of a document in a dedicated `/roles_admin` collection, rather than relying on custom claims.
 *
 * ## Data Structure
 * The data is organized into three main areas:
 * 1.  `/products/{productId}`: A top-level collection for the public product catalog.
 * 2.  `/users/{userId}`: A top-level collection where each document represents a user and serves as a root for their private data.
 * 3.  `/users/{userId}/orders/{orderId}`: A subcollection containing orders, strictly owned by the parent user.
 * 4.  `/roles_admin/{uid}`: A special, client-inaccessible collection used to designate administrators.
 *
 * ## Key Security Decisions
 * - **Public Product Catalog**: All users, authenticated or not, can read the `/products` collection. However, only administrators can modify it.
 * - **Strict User Data Isolation**: Users can only access their own data tree under `/users/{userId}`. They are explicitly forbidden from listing or reading other users' documents, preventing user enumeration.
 * - **Admin Override**: Users designated as admins have read-only access to all user data (`/users` and `/users/{userId}/orders`) for support and moderation purposes. Admins cannot write data on behalf of users to prevent unintended side effects.
 * - **Client-Side Role Management Disabled**: The `/roles_admin` collection is not writable by any client to prevent privilege escalation. It is expected to be managed securely through the Firebase Console or a trusted server environment.
 *
 * ## Denormalization for Authorization
 * To ensure fast and secure rule evaluation, this ruleset relies on denormalization:
 * - **Admin Roles**: Instead of embedding roles in a user document and performing a costly `get()` on every check, admin status is determined by a highly performant `exists()` call to the `/roles_admin/{uid}` path. This makes admin checks cheap and decoupled from the user's profile data.
 *
 * ## Structural Segregation
 * A clear separation is maintained between public and private data. The `/products` collection contains only public information, allowing for safe and efficient public `list` queries. All private user data is stored within the `/users/{userId}` path, ensuring that all queries against it are inherently constrained by user ownership rules.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // ----------------------------------------------------------------------
    // Helper Functions
    // ----------------------------------------------------------------------

    /**
     * Returns true if the user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Returns true if the authenticated user's UID matches the provided userId.
     * This is the foundation of the user-ownership model.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * Returns true if the requesting user is an administrator.
     * Checks for the existence of a document in the roles_admin collection.
     * This is a performant check that does not require read access to the document itself.
     */
    function isAdmin() {
      return isSignedIn() && exists(/databases/$(database)/documents/roles_admin/$(request.auth.uid));
    }

    /**
     * Returns true if the document being accessed already exists in Firestore.
     * CRITICAL for preventing writes to non-existent documents in update/delete operations.
     */
    function documentExists() {
      return resource != null;
    }

    // ----------------------------------------------------------------------
    // Collection Rules
    // ----------------------------------------------------------------------

    /**
     * @description Controls access to the public product catalog.
     * @path /products/{productId}
     * @allow (get) Any user, authenticated or not, can view a product.
     * @deny (create) An authenticated non-admin user cannot create a new product.
     * @principle Public read with admin-only writes.
     */
    match /products/{productId} {
      allow get, list: if true;
      allow create: if isAdmin();
      allow update: if isAdmin() && documentExists();
      allow delete: if isAdmin() && documentExists();
    }

    /**
     * @description Controls access to a user's own profile document.
     * @path /users/{userId}
     * @allow (create) A new user can create their own user document `if request.auth.uid == userId`.
     * @deny (list) A user cannot list all documents in the `/users` collection to prevent enumeration.
     * @deny (delete) A user cannot delete their own profile from the client. This should be a backend operation.
     * @principle Restricts access to a user's own data tree and prevents user enumeration.
     */
    match /users/{userId} {
      allow get: if isOwner(userId) || isAdmin();
      allow list: if false;
      allow create: if isOwner(userId);
      allow update: if isOwner(userId) && documentExists();
      allow delete: if false;
    }

    /**
     * @description Controls access to a user's private orders.
     * @path /users/{userId}/orders/{orderId}
     * @allow (create) An authenticated user can create an order for themselves under their own user path.
     * @deny (get) A user cannot read orders belonging to another user.
     * @principle Enforces strict document ownership within a user's data tree.
     */
    match /users/{userId}/orders/{orderId} {
      allow get, list: if isOwner(userId) || isAdmin();
      allow create: if isOwner(userId);
      allow update: if isOwner(userId) && documentExists();
      allow delete: if isOwner(userId) && documentExists();
    }

    /**
     * @description Secures the admin role collection.
     * @path /roles_admin/{uid}
     * @allow (none) No client-side reads or writes are permitted.
     * @deny (create) A user cannot make themselves an admin.
     * @deny (get) A user cannot check if another user is an admin.
     * @principle Prevents privilege escalation and information leakage by making role management a server-side-only operation.
     */
    match /roles_admin/{uid} {
      allow get: if false;
      allow list: if false;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }
  }
}